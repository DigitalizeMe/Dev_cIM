@prefix sh:    <http://www.w3.org/ns/shacl#> .
@prefix xsd:   <http://www.w3.org/2001/XMLSchema#> .
@prefix occp:  <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#> .
@prefix time:  <http://www.w3.org/2006/time#> .
@prefix osh:   <http://www.occpshape.de/shape#> .

#################################################################
#    SHACL Rules
#################################################################

### GENERAL SHACL RULES

    osh:GeneralDatePropertyShape a sh:PropertyShape ;
        sh:path ( occp:hasActualTime occp:hasEstimatedTime ) ;
        sh:datatype xsd:date ;
        sh:message "Dates must be in YYYY-MM-DD format."@en ;
        sh:severity sh:Violation .

    osh:GeneralTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each entity must have at most one actual beginning via 'occp:hasActualBeginning'."@en ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each entity must have at most one actual end via 'occp:hasActualEnd'."@en ;
            sh:severity sh:Violation ;
        ] ;
        # Ensure at least one beginning (actual OR estimated)
        sh:and (
            [ sh:property [ sh:path occp:hasPhase ; sh:minCount 1 ] ] # Applies only to phases explicitly linked to an instant
                [ sh:or (
                    [ sh:property [ sh:path occp:hasActualBeginning ; sh:minCount 1 ] ]
                    [ sh:property [ sh:path occp:hasEstimatedBeginning ; sh:minCount 1 ] ]
                )
                ]
                [ sh:or (
                    [ sh:property [ sh:path occp:hasActualEnd ; sh:minCount 1 ] ]
                    [ sh:property [ sh:path occp:hasEstimatedEnd ; sh:minCount 1 ] ]
                )
                ]
            ) ;
            sh:message "Phases explicitly linked to an instant via 'occp:hasPhase' must have both at least one beginning (actual or estimated) AND one end (actual or estimated)."@en ;
            sh:severity sh:Violation .

    osh:InstantTimeShape a sh:NodeShape ;
        sh:targetClass time:Instant ;
        sh:property [
            sh:path [ sh:alternativePath ( occp:hasActualTime occp:hasEstimatedTime ) ] ;
            sh:qualifiedValueShape [
                sh:datatype xsd:date ;
            ] ;
            sh:qualifiedMinCount 1 ;
            sh:message "Each instant must have at least one timestamp (either 'occp:hasActualTime' or 'occp:hasEstimatedTime') of type xsd:date."@en ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path occp:hasActualTime ;
            sh:datatype xsd:date ;
            sh:maxCount 1 ;
            sh:message "Each instant must have at most one actual timestamp via occp:hasActualTime of type xsd:date."@en ;
            sh:severity sh:Violation ;
        ] .

    osh:SiteShape a sh:NodeShape ;
        sh:targetClass occp:Site ;
        sh:property [
            sh:path occp:hasLifecycle ;
            sh:minCount 0 ;
            sh:class occp:Lifecycle ;
            sh:message "A Site must have at least one Lifecycle." 
        ] .


### CYCLE RELATED SHACL RULES

    osh:CycleShape a sh:NodeShape ;
        sh:targetClass occp:Cycle ;
        # Constraint for hasCycleNumber
        sh:property [
            sh:path occp:hasCycleNumber ;
            sh:datatype xsd:integer ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:minInclusive 1 ;
            sh:message "Each 'occp:Cycle' must specify exactly one positive integer via 'occp:hasCycleNumber' to indicate the number of iterations."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path time:hasActualBeginning ;
            sh:class time:Instant ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:Cycle' must have exactly one 'time:hasActualBeginning' referencing a 'time:Instant' to mark its start."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for end (at least one end: actual or estimated, but max 1 actualEnd)
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:Cycle' must have at most one 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ sh:path occp:hasActualEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
            [ sh:property [ sh:path occp:hasEstimatedEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
        ) ;
        sh:message "Each 'occp:Cycle' must have at least one end (either 'occp:hasActualEnd' or 'occp:hasEstimatedEnd') referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation .

    osh:CycleAShape a sh:NodeShape ;
        sh:targetClass occp:CycleA_PlanningReview ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:or (
                [ sh:class occp:BeginningOfPlanning ]
                [ sh:class occp:SubmissionToReview ]
            ) ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:CycleA_PlanningReview' must have exactly one actual beginning via 'occp:hasActualBeginning' referencing 'occp:SubmissionToReview' or 'occp:BeginningOfPlanning'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for end (at least one end: actual or estimated, restricted to ReviewApproval or ReviewRejection, max 1 actualEnd)
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ReviewApproval ]
                [ sh:class occp:ReviewRejection ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:CycleA_PlanningReview' must have at most one 'occp:hasActualEnd' referencing 'occp:ReviewApproval' or 'occp:ReviewRejection'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ 
                sh:path occp:hasActualEnd ; 
                sh:minCount 1 ;
                sh:or (
                    [ sh:class occp:ReviewApproval ]
                    [ sh:class occp:ReviewRejection ]
                ) 
            ] ]
            [ sh:property [ 
                sh:path occp:hasEstimatedEnd ; 
                sh:minCount 1 ;
                sh:or (
                    [ sh:class occp:ReviewApproval ]
                    [ sh:class occp:ReviewRejection ]
                ) 
            ] ]
        ) ;
        sh:message "Each 'occp:CycleA_PlanningReview' must have at least one end (either 'occp:hasActualEnd' or 'occp:hasEstimatedEnd') referencing 'occp:ReviewApproval' or 'occp:ReviewRejection'."@en ;
        sh:severity sh:Violation .

    osh:LifeCycleShape a sh:NodeShape ;
        sh:targetClass occp:LifeCycle ;
        # Constraint for hasLifeCycleID
        sh:property [
            sh:path occp:hasLifeCycleID ;
            sh:datatype xsd:string ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:LifeCycle' must have exactly one 'occp:hasLifeCycleID' of type xsd:string to provide a unique identifier."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for isInPhase
        sh:property [
            sh:path occp:isInPhase ;
            sh:class occp:Phase ;
            sh:minCount 1 ;
            sh:message "Each 'occp:LifeCycle' must be embedded in at least one 'occp:Phase' via 'occp:isInPhase'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for beginning (at least one: actual or estimated, max 1 actualBeginning)
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:LifeCycle' must have at most one 'occp:hasActualBeginning' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ sh:path occp:hasActualBeginning ; sh:minCount 1 ; sh:class time:Instant ] ]
            [ sh:property [ sh:path occp:hasEstimatedBeginning ; sh:minCount 1 ; sh:class time:Instant ] ]
        ) ;
        sh:message "Each 'occp:LifeCycle' must have at least one beginning (either 'occp:hasActualBeginning' or 'occp:hasEstimatedBeginning') referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation ;
        # Constraint for end (at least one: actual or estimated, max 1 actualEnd)
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:LifeCycle' must have at most one 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ sh:path occp:hasActualEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
            [ sh:property [ sh:path occp:hasEstimatedEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
        ) ;
        sh:message "Each 'occp:LifeCycle' must have at least one end (either 'occp:hasActualEnd' or 'occp:hasEstimatedEnd') referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation ;
        # Constraint to ensure LifeCycle times are within the embedding Phase's times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phase ?startLC ?endLC ?startPhase ?endPhase
                WHERE {
                    # Get LifeCycle start time (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstLC . 
                    ?startInstLC occp:hasActualTime ?startLC . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstLC . 
                    ?startInstLC occp:hasEstimatedTime ?startLC . }
                    # Get LifeCycle end time (actual or estimated)
                    { $this occp:hasActualEnd ?endInstLC . 
                    ?endInstLC occp:hasActualTime ?endLC . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstLC . 
                    ?endInstLC occp:hasEstimatedTime ?endLC . }
                    # Get embedding Phase
                    $this occp:isInPhase ?phase .
                    # Get Phase start time (actual or estimated)
                    { ?phase occp:hasActualBeginning ?startInstPhase . 
                    ?startInstPhase occp:hasActualTime ?startPhase . }
                    UNION
                    { ?phase occp:hasEstimatedBeginning ?startInstPhase . 
                    ?startInstPhase occp:hasEstimatedTime ?startPhase . }
                    # Get Phase end time (actual or estimated)
                    { ?phase occp:hasActualEnd ?endInstPhase . 
                    ?endInstPhase occp:hasActualTime ?endPhase . }
                    UNION
                    { ?phase occp:hasEstimatedEnd ?endInstPhase . 
                    ?endInstPhase occp:hasEstimatedTime ?endPhase . }
                    # Check conditions: startLC >= startPhase and endLC <= endPhase
                    FILTER (?startLC < ?startPhase || ?endLC > ?endPhase)
                }
            """ ;
            sh:message "Each 'occp:LifeCycle' { $this } (start: { ?startLC }, end: { ?endLC }) must have its beginning after or equal to the beginning of its embedding phase { ?phase } (start: { ?startPhase }) and its end before or equal to the end of the phase (end: { ?endPhase })."@en ;
            sh:severity sh:Violation
        ] .

### PHASE RELATED SHACL RULES

    osh:ShapeOfPhaseA a sh:NodeShape ;
        sh:targetClass occp:PhaseA_Planning ;
        # Ensure PhaseA begins before PhaseB_Review based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseB ?startA ?startB
                WHERE {
                    # Get start time of PhaseA (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantA . 
                    ?startInstantA occp:hasActualTime ?startA . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantA . 
                    ?startInstantA occp:hasEstimatedTime ?startA . }
                    # Get start time of PhaseB (actual or estimated)
                    ?phaseB a occp:PhaseB_Review .
                    { ?phaseB occp:hasActualBeginning ?startInstantB . 
                    ?startInstantB occp:hasActualTime ?startB . }
                    UNION
                    { ?phaseB occp:hasEstimatedBeginning ?startInstantB . 
                    ?startInstantB occp:hasEstimatedTime ?startB . }
                    FILTER (?startA >= ?startB)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (start: { ?startA }) must begin before PhaseB_Review { ?phaseB } (start: { ?startB })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseA begins before PhaseC_Construction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?startA ?startC
                WHERE {
                    # Get start time of PhaseA (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantA . 
                    ?startInstantA occp:hasActualTime ?startA . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantA . 
                    ?startInstantA occp:hasEstimatedTime ?startA . }
                    # Get start time of PhaseC (actual or estimated)
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?startA >= ?startC)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (start: { ?startA }) must begin before PhaseC_Construction { ?phaseC } (start: { ?startC })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseA ends before PhaseC_Construction begins based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?endA ?startC
                WHERE {
                    # Get end time of PhaseA (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantA . 
                    ?endInstantA occp:hasActualTime ?endA . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantA . 
                    ?endInstantA occp:hasEstimatedTime ?endA . }
                    # Get start time of PhaseC (actual or estimated)
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?endA >= ?startC)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (end: { ?endA }) must end before PhaseC_Construction { ?phaseC } begins (start: { ?startC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseA ends before CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?endA ?timeC
                WHERE {
                    # Get end time of PhaseA (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantA . 
                    ?endInstantA occp:hasActualTime ?endA . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantA . 
                    ?endInstantA occp:hasEstimatedTime ?endA . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeC . }
                    FILTER (?endA >= ?timeC)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (end: { ?endA }) must end before CompletionOfConstruction { ?completion } (time: { ?timeC })."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:BeginningOfPlanning ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseA_Planning' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:BeginningOfPlanning'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ReviewApproval ]
                [ sh:class occp:CompletionOfPlanning ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseA_Planning' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:ReviewApproval' or 'occp:CompletionOfPlanning'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseB a sh:NodeShape ;
        sh:targetClass occp:PhaseB_Review ;
        # Ensure PhaseB begins before PhaseC_Construction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?startB ?startC
                WHERE {
                    { $this occp:hasActualBeginning ?startInstantB . 
                    ?startInstantB occp:hasActualTime ?startB . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantB . 
                    ?startInstantB occp:hasEstimatedTime ?startB . }
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?startB >= ?startC)
                }
            """ ;
            sh:message "PhaseB_Review { $this } (start: { ?startB }) must begin before PhaseC_Construction { ?phaseC } (start: { ?startC })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseB occurs entirely before PhaseC_Construction (endB < startC) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?endB ?startC
                WHERE {
                    { $this occp:hasActualEnd ?endInstantB . 
                    ?endInstantB occp:hasActualTime ?endB . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantB . 
                    ?endInstantB occp:hasEstimatedTime ?endB . }
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?endB >= ?startC)
                }
            """ ;
            sh:message "PhaseB_Review { $this } (end: { ?endB }) must end before PhaseC_Construction { ?phaseC } begins (start: { ?startC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseB ends before or with CompletionOfPlanning based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?endB ?timeCOP
                WHERE {
                    { $this occp:hasActualEnd ?endInstantB . 
                    ?endInstantB occp:hasActualTime ?endB . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantB . 
                    ?endInstantB occp:hasEstimatedTime ?endB . }
                    ?completion a occp:CompletionOfPlanning .
                    { ?completion occp:hasActualTime ?timeCOP . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOP . }
                    FILTER (?endB > ?timeCOP)
                }
            """ ;
            sh:message "PhaseB_Review { $this } (end: { ?endB }) must end before or with CompletionOfPlanning { ?completion } (time: { ?timeCOP })."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:SubmissionToReview ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseB_Review' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:SubmissionToReview'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ReviewApproval ]
                [ sh:class occp:CompletionOfPlanning ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseB_Review' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:ReviewApproval' or 'occp:CompletionOfPlanning'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfTransitionA a sh:NodeShape ;         # Transition A (Completion of Planning)
        sh:targetClass occp:CompletionOfPlanning ;
        # Ensure CompletionOfPlanning occurs before BeginOfTenderingProcess based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?beginTender ?timeCOP ?startTender
                WHERE {
                    # Get time of CompletionOfPlanning (actual or estimated)
                    { $this occp:hasActualTime ?timeCOP . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOP . }
                    # Get start time of BeginOfTenderingProcess (actual or estimated)
                    ?beginTender a occp:BeginOfTenderingProcess .
                    { ?beginTender occp:hasActualTime ?startTender . }
                    UNION
                    { ?beginTender occp:hasEstimatedTime ?startTender . }
                    FILTER (?timeCOP >= ?startTender)
                }
            """ ;
            sh:message "CompletionOfPlanning { $this } (time: { ?timeCOP }) should occur before BeginOfTenderingProcess { ?beginTender } (time: { ?startTender })."@en ;
            sh:severity sh:Warning
        ] .

    osh:ShapeOfTransitionB a sh:NodeShape ;         # Transition B (Begin Of Tendering Process)
        sh:targetClass occp:BeginOfTenderingProcess ;
        # Ensure BeginOfTenderingProcess occurs before Submission based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startTender ?timeSub
                WHERE {
                    # Get time of BeginOfTenderingProcess (actual or estimated)
                    { $this occp:hasActualTime ?startTender . }
                    UNION
                    { $this occp:hasEstimatedTime ?startTender . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startTender >= ?timeSub)
                }
            """ ;
            sh:message "BeginOfTenderingProcess { $this } (time: { ?startTender }) should occur before Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] .
    osh:ShapeOfTransitionC a sh:NodeShape ;         # Transition C (Submission)
        sh:targetClass occp:Submission ;
        # Ensure Submission occurs before PhaseC_Construction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?timeSub ?startC
                WHERE {
                    # Get time of Submission (actual or estimated)
                    { $this occp:hasActualTime ?timeSub . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeSub . }
                    # Get start time of PhaseC_Construction (actual or estimated)
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?timeSub >= ?startC)
                }
            """ ;
            sh:message "Submission { $this } (time: { ?timeSub }) should occur before PhaseC_Construction { ?phaseC } (start: { ?startC })."@en ;
            sh:severity sh:Warning
        ] .

    osh:ShapeOfPhaseC a sh:NodeShape ;              # Phase C (Construction)
        sh:targetClass occp:PhaseC_Construction ;
        # Ensure PhaseC occurs after CompletionOfPlanning (startC > timeCOP) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startC ?timeCOP
                WHERE {
                    # Get start time of PhaseC (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    # Get time of CompletionOfPlanning (actual or estimated)
                    ?completion a occp:CompletionOfPlanning .
                    { ?completion occp:hasActualTime ?timeCOP . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOP . }
                    FILTER (?startC <= ?timeCOP)
                }
            """ ;
            sh:message "PhaseC_Construction { $this } (start: { ?startC }) should occur after CompletionOfPlanning { ?completion } (time: { ?timeCOP })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseC occurs after Submission (startC > timeSub) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startC ?timeSub
                WHERE {
                    # Get start time of PhaseC (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startC <= ?timeSub)
                }
            """ ;
            sh:message "PhaseC_Construction { $this } (start: { ?startC }) should occur after Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:ConstructionStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseC_Construction' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:ConstructionStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:ConstructionAcceptance ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseC_Construction' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:ConstructionAcceptance'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfTransitionD a sh:NodeShape ;         # Transition D (Completion Of Construction)
        sh:targetClass occp:CompletionOfConstruction ;
        # Ensure CompletionOfConstruction occurs after CompletionOfPlanning based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionPlanning ?timeCOC ?timeCOP
                WHERE {
                    # Get time of CompletionOfConstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOC . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOC . }
                    # Get time of CompletionOfPlanning (actual or estimated)
                    ?completionPlanning a occp:CompletionOfPlanning .
                    { ?completionPlanning occp:hasActualTime ?timeCOP . }
                    UNION
                    { ?completionPlanning occp:hasEstimatedTime ?timeCOP . }
                    FILTER (?timeCOC <= ?timeCOP)
                }
            """ ;
            sh:message "CompletionOfConstruction { $this } (time: { ?timeCOC }) should occur after CompletionOfPlanning { ?completionPlanning } (time: { ?timeCOP })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure CompletionOfConstruction occurs before PhaseD_Usage based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseD ?timeCOC ?startD
                WHERE {
                    # Get time of CompletionOfConstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOC . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOC . }
                    # Get start time of PhaseD_Usage (actual or estimated)
                    ?phaseD a occp:PhaseD_Usage .
                    { ?phaseD occp:hasActualBeginning ?startInstantD . 
                    ?startInstantD occp:hasActualTime ?startD . }
                    UNION
                    { ?phaseD occp:hasEstimatedBeginning ?startInstantD . 
                    ?startInstantD occp:hasEstimatedTime ?startD . }
                    FILTER (?timeCOC >= ?startD)
                }
            """ ;
            sh:message "CompletionOfConstruction { $this } (time: { ?timeCOC }) should occur before PhaseD_Usage { ?phaseD } (start: { ?startD })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure CompletionOfConstruction occurs before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?timeCOC ?startM
                WHERE {
                    # Get time of CompletionOfConstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOC . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOC . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?timeCOC >= ?startM)
                }
            """ ;
            sh:message "CompletionOfConstruction { $this } (time: { ?timeCOC }) should occur before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] .

    osh:ShapeOfPhaseD a sh:NodeShape ;              # Phase D (Usage)
        sh:targetClass occp:PhaseD_Usage ;
        # Ensure PhaseD occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionC ?startD ?timeCOC
                WHERE {
                    # Get start time of PhaseD (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantD . 
                    ?startInstantD occp:hasActualTime ?startD . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantD . 
                    ?startInstantD occp:hasEstimatedTime ?startD . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completionC a occp:CompletionOfConstruction .
                    { ?completionC occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completionC occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startD <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseD_Usage { $this } (start: { ?startD }) should occur after CompletionOfConstruction { ?completionC } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseD ends before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endD ?startM
                WHERE {
                    # Get end time of PhaseD (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantD . 
                    ?endInstantD occp:hasActualTime ?endD . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantD . 
                    ?endInstantD occp:hasEstimatedTime ?endD . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endD >= ?startM)
                }
            """ ;
            sh:message "PhaseD_Usage { $this } (end: { ?endD }) should end before PhaseM_Deconstruction { ?phaseM } (start: { ?startM }). We donâ€™t want anyone to get hurt, do we?"@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:UsageStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseD_Usage' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:UsageStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:UsageEnd ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseD_Usage' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:UsageEnd'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseE a sh:NodeShape ;              # Phase E (Warranty)
        sh:targetClass occp:PhaseE_Warranty ;
        # Ensure PhaseE occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startE ?timeCOC
                WHERE {
                    # Get start time of PhaseE (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantE . 
                    ?startInstantE occp:hasActualTime ?startE . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantE . 
                    ?startInstantE occp:hasEstimatedTime ?startE . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startE <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseE_Warranty { $this } (start: { ?startE }) should occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:WarrantyStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseE_Warranty' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:WarrantyStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:WarrantyEnd ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseE_Warranty' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:WarrantyEnd'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseF a sh:NodeShape ;              # Phase F (DesignLife)
        sh:targetClass occp:PhaseF_DesignLife ;
        # Ensure PhaseF occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startF ?timeCOC
                WHERE {
                    # Get start time of PhaseF (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantF . 
                    ?startInstantF occp:hasActualTime ?startF . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantF . 
                    ?startInstantF occp:hasEstimatedTime ?startF . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startF <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseF_DesignLife { $this } (start: { ?startF }) should occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseF begins before or with PhaseD_Usage based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseD ?startF ?startD
                WHERE {
                    # Get start time of PhaseF (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantF . 
                    ?startInstantF occp:hasActualTime ?startF . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantF . 
                    ?startInstantF occp:hasEstimatedTime ?startF . }
                    # Get start time of PhaseD_Usage (actual or estimated)
                    ?phaseD a occp:PhaseD_Usage .
                    { ?phaseD occp:hasActualBeginning ?startInstantD . 
                    ?startInstantD occp:hasActualTime ?startD . }
                    UNION
                    { ?phaseD occp:hasEstimatedBeginning ?startInstantD . 
                    ?startInstantD occp:hasEstimatedTime ?startD . }
                    FILTER (?startF > ?startD)
                }
            """ ;
            sh:message "PhaseF_DesignLife { $this } (start: { ?startF }) should begin before or with PhaseD_Usage { ?phaseD } (start: { ?startD })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseF occurs before PhaseM_Deconstruction (endF < startM) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endF ?startM
                WHERE {
                    # Get end time of PhaseF (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantF . 
                    ?endInstantF occp:hasActualTime ?endF . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantF . 
                    ?endInstantF occp:hasEstimatedTime ?endF . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endF >= ?startM)
                }
            """ ;
            sh:message "PhaseF_DesignLife { $this } (end: { ?endF }) should occur before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:DesignLifeStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseF_DesignLife' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:DesignLifeStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:DesignLifeEnd ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseF_DesignLife' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:DesignLifeEnd'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseG a sh:NodeShape ;              # Phase G (Inspection)
        sh:targetClass occp:PhaseG_Inspection ;
        # Ensure PhaseG begins with or after UsageStart based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?usageStart ?startG ?timeUS
                WHERE {
                    # Get start time of PhaseG (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantG . 
                    ?startInstantG occp:hasActualTime ?startG . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantG . 
                    ?startInstantG occp:hasEstimatedTime ?startG . }
                    # Get time of UsageStart (actual or estimated)
                    ?usageStart a occp:UsageStart .
                    { ?usageStart occp:hasActualTime ?timeUS . }
                    UNION
                    { ?usageStart occp:hasEstimatedTime ?timeUS . }
                    FILTER (?startG < ?timeUS)
                }
            """ ;
            sh:message "PhaseG_Inspection { $this } (start: { ?startG }) must begin with or after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseG occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startG ?timeCOC
                WHERE {
                    # Get start time of PhaseG (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantG . 
                    ?startInstantG occp:hasActualTime ?startG . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantG . 
                    ?startInstantG occp:hasEstimatedTime ?startG . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startG <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseG_Inspection { $this } (start: { ?startG }) should occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseG occurs before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endG ?startM
                WHERE {
                    # Get end time of PhaseG (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantG . 
                    ?endInstantG occp:hasActualTime ?endG . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantG . 
                    ?endInstantG occp:hasEstimatedTime ?endG . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endG >= ?startM)
                }
            """ ;
            sh:message "PhaseG_Inspection { $this } (end: { ?endG }) should occur before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:InspectionExecution ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseG_Inspection' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:InspectionExecution'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseG_Inspection' must have at most one actual end via 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] .


        osh:ShapeOfPhaseH a sh:NodeShape ;              # Phase H (SpecialEvents) - Special events can occur anytime, so this is to be handled like a super-phase. It can be used to describe or record events that have shaped the landscape like earthquakes in the past, but also events that occur during or after the construction's life cycle.
            sh:targetClass occp:PhaseH_SpecialEvents ;
            # Ensure each PhaseH has at least one instant to mark specific events
            sh:property [
                sh:path occp:hasInstant ;
                sh:class time:Instant ;
                sh:minCount 1 ;
                sh:message "Each 'occp:PhaseH_SpecialEvents' must have at least one instant via 'occp:hasInstant' referencing a 'time:Instant' (e.g., 'occp:GeologicalEvent', 'occp:WeatherEvent')."@en ;
                sh:severity sh:Violation
            ] ;
            # Constraint for hasActualBeginning
            sh:property [
                sh:path occp:hasActualBeginning ;
                sh:class time:Instant ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:PhaseH_SpecialEvents' must have at most one actual beginning via 'occp:hasActualBeginning' referencing a 'time:Instant'."@en ;
                sh:severity sh:Violation
            ] ;
            # Constraint for hasActualEnd
            sh:property [
                sh:path occp:hasActualEnd ;
                sh:class time:Instant ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:PhaseH_SpecialEvents' must have at most one actual end via 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
                sh:severity sh:Violation
            ] .

    osh:ShapeOfPhaseK a sh:NodeShape ;              # Phase K (Damage)
        sh:targetClass occp:PhaseK_Damage ;
        # Ensure PhaseK occurs after Submission based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startK ?timeSub
                WHERE {
                    # Get start time of PhaseK (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantK . 
                    ?startInstantK occp:hasActualTime ?startK . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantK . 
                    ?startInstantK occp:hasEstimatedTime ?startK . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startK <= ?timeSub)
                }
            """ ;
            sh:message "PhaseK_Damage { $this } (start: { ?startK }) should occur after Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseK occurs before CompletionOfDeconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionDec ?endK ?timeCOD
                WHERE {
                    # Get end time of PhaseK (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantK . 
                    ?endInstantK occp:hasActualTime ?endK . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantK . 
                    ?endInstantK occp:hasEstimatedTime ?endK . }
                    # Get time of CompletionOfDeconstruction (actual or estimated)
                    ?completionDec a occp:CompletionOfDeconstruction .
                    { ?completionDec occp:hasActualTime ?timeCOD . }
                    UNION
                    { ?completionDec occp:hasEstimatedTime ?timeCOD . }
                    FILTER (?endK >= ?timeCOD)
                }
            """ ;
            sh:message "PhaseK_Damage { $this } (end: { ?endK }) should occur before CompletionOfDeconstruction { ?completionDec } (time: { ?timeCOD })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseK begins before PhaseL_Repair based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseL ?startK ?startL
                WHERE {
                    # Get start time of PhaseK (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantK . 
                    ?startInstantK occp:hasActualTime ?startK . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantK . 
                    ?startInstantK occp:hasEstimatedTime ?startK . }
                    # Get start time of PhaseL_Repair (actual or estimated)
                    ?phaseL a occp:PhaseL_Repair .
                    { ?phaseL occp:hasActualBeginning ?startInstantL . 
                    ?startInstantL occp:hasActualTime ?startL . }
                    UNION
                    { ?phaseL occp:hasEstimatedBeginning ?startInstantL . 
                    ?startInstantL occp:hasEstimatedTime ?startL . }
                    FILTER (?startK >= ?startL)
                }
            """ ;
            sh:message "PhaseK_Damage { $this } (start: { ?startK }) should begin before PhaseL_Repair { ?phaseL } (start: { ?startL }), but damage detection during repair is possible."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:DamageDetection ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseK_Damage' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:DamageDetection'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseK_Damage' must have at most one actual end via 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseL a sh:NodeShape ;              # Phase L (Repair)
        sh:targetClass occp:PhaseL_Repair ;
        # Ensure PhaseL ends with or after PhaseK_Damage based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseK ?endL ?endK
                WHERE {
                    # Get end time of PhaseL (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantL . 
                    ?endInstantL occp:hasActualTime ?endL . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantL . 
                    ?endInstantL occp:hasEstimatedTime ?endL . }
                    # Get end time of PhaseK_Damage (actual or estimated)
                    ?phaseK a occp:PhaseK_Damage .
                    { ?phaseK occp:hasActualEnd ?endInstantK . 
                    ?endInstantK occp:hasActualTime ?endK . }
                    UNION
                    { ?phaseK occp:hasEstimatedEnd ?endInstantK . 
                    ?endInstantK occp:hasEstimatedTime ?endK . }
                    FILTER (?endL < ?endK)
                }
            """ ;
            sh:message "PhaseL_Repair { $this } (end: { ?endL }) must end with or after PhaseK_Damage { ?phaseK } (end: { ?endK })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseL occurs after Submission based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startL ?timeSub
                WHERE {
                    # Get start time of PhaseL (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantL . 
                    ?startInstantL occp:hasActualTime ?startL . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantL . 
                    ?startInstantL occp:hasEstimatedTime ?startL . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startL <= ?timeSub)
                }
            """ ;
            sh:message "PhaseL_Repair { $this } (start: { ?startL }) should occur after Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseL ends before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endL ?startM
                WHERE {
                    # Get end time of PhaseL (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantL . 
                    ?endInstantL occp:hasActualTime ?endL . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantL . 
                    ?endInstantL occp:hasEstimatedTime ?endL . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endL >= ?startM)
                }
            """ ;
            sh:message "PhaseL_Repair { $this } (end: { ?endL }) should end before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:RepairStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseL_Repair' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:RepairStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:RepairCompletion ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseL_Repair' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:RepairCompletion'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseM a sh:NodeShape ;              # Phase M (Deconstruction)
        sh:targetClass occp:PhaseM_Deconstruction ;
        # Ensure PhaseM occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionC ?startM ?timeCOC
                WHERE {
                    # Get start time of PhaseM (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completionC a occp:CompletionOfConstruction .
                    { ?completionC occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completionC occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startM <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseM_Deconstruction { $this } (start: { ?startM }) should occur after CompletionOfConstruction { ?completionC } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:DeconstructionStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseM_Deconstruction' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:DeconstructionStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:CompletionOfDeconstruction ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseM_Deconstruction' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:CompletionOfDeconstruction'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfTransitionE a sh:NodeShape ;         # Transition E (Completion Of Deconstruction)
        sh:targetClass occp:CompletionOfDeconstruction ;
        # Ensure CompletionOfDeconstruction occurs after or with the end of PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?timeCOD ?endM
                WHERE {
                    # Get time of CompletionOfDeconstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOD . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOD . }
                    # Get end time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualEnd ?endInstantM . 
                    ?endInstantM occp:hasActualTime ?endM . }
                    UNION
                    { ?phaseM occp:hasEstimatedEnd ?endInstantM . 
                    ?endInstantM occp:hasEstimatedTime ?endM . }
                    FILTER (?timeCOD < ?endM)
                }
            """ ;
            sh:message "CompletionOfDeconstruction { $this } (time: { ?timeCOD }) must occur after or with the end of PhaseM_Deconstruction { ?phaseM } (end: { ?endM })."@en ;
            sh:severity sh:Violation
        ] .


### INSTANT RELATED SHACL RULES
    ### PHASE A INSTANTS
        # PHASE ASSIGNMENT

            osh:PhaseAInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseA_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseA_Planning ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseA_Instant' must belong to exactly one 'occp:PhaseA_Planning' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE A - PLANNING

            osh:BeginningOfPlanningShape a sh:NodeShape ;   # Instant Beginning Of Planning (Phase A - Planning)
                sh:targetClass occp:BeginningOfPlanning ;
                # Instant (Beginning Of Planning) starts a new Phase A (Planning)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseA_Planning ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:BeginningOfPlanning' must start exactly one 'occp:PhaseA_Planning' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure BeginningOfPlanning occurs before DataProcurement based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?dataProc ?timeBOP ?timeDP
                        WHERE {
                            # Get time of BeginningOfPlanning (actual or estimated)
                            { $this occp:hasActualTime ?timeBOP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeBOP . }
                            # Get time of DataProcurement (actual or estimated)
                            ?dataProc a occp:DataProcurement .
                            { ?dataProc occp:hasActualTime ?timeDP . }
                            UNION
                            { ?dataProc occp:hasEstimatedTime ?timeDP . }
                            FILTER (?timeBOP >= ?timeDP)
                        }
                    """ ;
                    sh:message "BeginningOfPlanning { $this } (time: { ?timeBOP }) must occur before DataProcurement { ?dataProc } (time: { ?timeDP })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure BeginningOfPlanning occurs before SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeBOP ?timeSub
                        WHERE {
                            # Get time of BeginningOfPlanning (actual or estimated)
                            { $this occp:hasActualTime ?timeBOP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeBOP . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeBOP >= ?timeSub)
                        }
                    """ ;
                    sh:message "BeginningOfPlanning { $this } (time: { ?timeBOP }) should occur before SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Warning
                ] .

            osh:DataProcurementShape a sh:NodeShape ;       # Instant Data Procurement (Phase A - Planning)
                sh:targetClass occp:DataProcurement ;
                # Ensure DataProcurement occurs after BeginningOfPlanning based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?beginPlanning ?timeDP ?timeBOP
                        WHERE {
                            # Get time of DataProcurement (actual or estimated)
                            { $this occp:hasActualTime ?timeDP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDP . }
                            # Get time of BeginningOfPlanning (actual or estimated)
                            ?beginPlanning a occp:BeginningOfPlanning .
                            { ?beginPlanning occp:hasActualTime ?timeBOP . }
                            UNION
                            { ?beginPlanning occp:hasEstimatedTime ?timeBOP . }
                            FILTER (?timeDP <= ?timeBOP)
                        }
                    """ ;
                    sh:message "DataProcurement { $this } (time: { ?timeDP }) must occur after BeginningOfPlanning { ?beginPlanning } (time: { ?timeBOP })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DataProcurement occurs before SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeDP ?timeSub
                        WHERE {
                            # Get time of DataProcurement (actual or estimated)
                            { $this occp:hasActualTime ?timeDP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDP . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeDP >= ?timeSub)
                        }
                    """ ;
                    sh:message "DataProcurement { $this } (time: { ?timeDP }) should occur before SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Warning
                ] .

            osh:Edit_BSTRShape a sh:NodeShape ;             # Instant Edit Before Submission To Review (Phase A - Planning)
                sh:targetClass occp:Edit_BSTR ;
                # Ensure Edit_BSTR occurs after BeginningOfPlanning based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?beginPlanning ?timeEdit ?timeBOP
                        WHERE {
                            # Get time of Edit_BSTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of BeginningOfPlanning (actual or estimated)
                            ?beginPlanning a occp:BeginningOfPlanning .
                            { ?beginPlanning occp:hasActualTime ?timeBOP . }
                            UNION
                            { ?beginPlanning occp:hasEstimatedTime ?timeBOP . }
                            FILTER (?timeEdit <= ?timeBOP)
                        }
                    """ ;
                    sh:message "Edit_BSTR { $this } (time: { ?timeEdit }) must occur after BeginningOfPlanning { ?beginPlanning } (time: { ?timeBOP })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure Edit_BSTR occurs before SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeEdit ?timeSub
                        WHERE {
                            # Get time of Edit_BSTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeEdit >= ?timeSub)
                        }
                    """ ;
                    sh:message "Edit_BSTR { $this } (time: { ?timeEdit }) must occur before SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:SubmissionToReviewShape a sh:NodeShape ;    # Instant Submission To Review (Phase A - Planning)
                sh:targetClass occp:SubmissionToReview ;
                # Ensure SubmissionToReview occurs after Edit_BSTR or Edit_ASTR based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?editEvent ?timeSub ?timeEdit
                        WHERE {
                            # Get time of SubmissionToReview (actual or estimated)
                            { $this occp:hasActualTime ?timeSub . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeSub . }
                            # Get time of Edit_BSTR or Edit_ASTR (actual or estimated)
                            ?editEvent a ?editClass .
                            FILTER (?editClass IN (occp:Edit_BSTR, occp:Edit_ASTR))
                            { ?editEvent occp:hasActualTime ?timeEdit . }
                            UNION
                            { ?editEvent occp:hasEstimatedTime ?timeEdit . }
                            FILTER (?timeSub <= ?timeEdit)
                        }
                    """ ;
                    sh:message "SubmissionToReview { $this } (time: { ?timeSub }) must occur after Edit_BSTR or Edit_ASTR { ?editEvent } (time: { ?timeEdit })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Instant starts a CycleA_PlanningReview
                sh:property [
                    sh:path occp:startsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:SubmissionToReview' must start at most one 'occp:CycleA_PlanningReview' via 'occp:startsCycle'."@en ;
                    sh:severity sh:Violation
                ] .

            osh:Edit_ASTRShape a sh:NodeShape ;             # Instant Edit After Submission To Review (Phase A - Planning)
                sh:targetClass occp:Edit_ASTR ;
                # Ensure Edit_ASTR occurs after SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeEdit ?timeSub
                        WHERE {
                            # Get time of Edit_ASTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeEdit <= ?timeSub)
                        }
                    """ ;
                    sh:message "Edit_ASTR { $this } (time: { ?timeEdit }) must occur after SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure Edit_ASTR occurs before CompletionOfPlanning based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeEdit ?timeCOP
                        WHERE {
                            # Get time of Edit_ASTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of CompletionOfPlanning (actual or estimated)
                            ?completion a occp:CompletionOfPlanning .
                            { ?completion occp:hasActualTime ?timeCOP . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCOP . }
                            FILTER (?timeEdit >= ?timeCOP)
                        }
                    """ ;
                    sh:message "Edit_ASTR { $this } (time: { ?timeEdit }) should occur before CompletionOfPlanning { ?completion } (time: { ?timeCOP })."@en ;
                    sh:severity sh:Warning
                ] .


    ### PHASE B INSTANTS
        # PHASE ASSIGNMENT        
        
            osh:PhaseBInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseB_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseB_Review ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseB_Instant' must belong to exactly one 'occp:PhaseB_Review' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE B - REVIEW

            osh:ReviewStartShape a sh:NodeShape ;           # Instant Review Start (Phase B - Review)
                sh:targetClass occp:ReviewStart ;
                # Instant (Review Start) starts a new Phase B (Review)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseB_Review ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewStart' must start exactly one 'occp:PhaseB_Review' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewStart occurs before ReviewApproval based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewApproval ?timeRS ?timeRA
                        WHERE {
                            # Get time of ReviewStart (actual or estimated)
                            { $this occp:hasActualTime ?timeRS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRS . }
                            # Get time of ReviewApproval (actual or estimated)
                            ?reviewApproval a occp:ReviewApproval .
                            { ?reviewApproval occp:hasActualTime ?timeRA . }
                            UNION
                            { ?reviewApproval occp:hasEstimatedTime ?timeRA . }
                            FILTER (?timeRS >= ?timeRA)
                        }
                    """ ;
                    sh:message "ReviewStart { $this } (time: { ?timeRS }) must occur before ReviewApproval { ?reviewApproval } (time: { ?timeRA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewStart occurs before ReviewRejection based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewRejection ?timeRS ?timeRR
                        WHERE {
                            # Get time of ReviewStart (actual or estimated)
                            { $this occp:hasActualTime ?timeRS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRS . }
                            # Get time of ReviewRejection (actual or estimated)
                            ?reviewRejection a occp:ReviewRejection .
                            { ?reviewRejection occp:hasActualTime ?timeRR . }
                            UNION
                            { ?reviewRejection occp:hasEstimatedTime ?timeRR . }
                            FILTER (?timeRS >= ?timeRR)
                        }
                    """ ;
                    sh:message "ReviewStart { $this } (time: { ?timeRS }) must occur before ReviewRejection { ?reviewRejection } (time: { ?timeRR })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewStart occurs after SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeRS ?timeSub
                        WHERE {
                            # Get time of ReviewStart (actual or estimated)
                            { $this occp:hasActualTime ?timeRS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRS . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeRS <= ?timeSub)
                        }
                    """ ;
                    sh:message "ReviewStart { $this } (time: { ?timeRS }) must occur after SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ReviewApprovalShape a sh:NodeShape ;
                sh:targetClass occp:ReviewApproval ;
                # Optional: endsPhase for PhaseA_Planning if it exists, max 1
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?phaseA ?timeRA ?startA
                        WHERE {
                            ?phaseA a occp:PhaseA_Planning .
                            $this occp:endsPhase ?phaseA .
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get start time of PhaseA (actual or estimated)
                            { ?phaseA occp:hasActualBeginning ?startInstA . 
                            ?startInstA occp:hasActualTime ?startA . }
                            UNION
                            { ?phaseA occp:hasEstimatedBeginning ?startInstA . 
                            ?startInstA occp:hasEstimatedTime ?startA . }
                            FILTER (?timeRA <= ?startA)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after the start of PhaseA_Planning { ?phaseA } (start: { ?startA })."@en ;
                    sh:severity sh:Violation
                ] ;
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseA_Planning ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewApproval' must end at most one 'occp:PhaseA_Planning' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Optional: endsPhase for PhaseB_Review if it exists, max 1
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?phaseB ?timeRA ?startB
                        WHERE {
                            ?phaseB a occp:PhaseB_Review .
                            $this occp:endsPhase ?phaseB .
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get start time of PhaseB (actual or estimated)
                            { ?phaseB occp:hasActualBeginning ?startInstB . 
                            ?startInstB occp:hasActualTime ?startB . }
                            UNION
                            { ?phaseB occp:hasEstimatedBeginning ?startInstB . 
                            ?startInstB occp:hasEstimatedTime ?startB . }
                            FILTER (?timeRA <= ?startB)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after the start of PhaseB_Review { ?phaseB } (start: { ?startB })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Optional: endsCycle for CycleA_PlanningReview if it exists, max 1
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?cycleA ?timeRA ?startA
                        WHERE {
                            ?cycleA a occp:CycleA_PlanningReview .
                            $this occp:endsCycle ?cycleA .
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get start time of CycleA (actual or estimated)
                            { ?cycleA occp:hasActualBeginning ?startInstA . 
                            ?startInstA occp:hasActualTime ?startA . }
                            UNION
                            { ?cycleA occp:hasEstimatedBeginning ?startInstA . 
                            ?startInstA occp:hasEstimatedTime ?startA . }
                            FILTER (?timeRA <= ?startA)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after the start of CycleA_PlanningReview { ?cycleA } (start: { ?startA })."@en ;
                    sh:severity sh:Violation
                ] ;
                sh:property [
                    sh:path occp:endsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewApproval' must end at most one 'occp:CycleA_PlanningReview' via 'occp:endsCycle'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewApproval occurs after ReviewStart if it exists
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewStart ?timeRA ?timeRS
                        WHERE {
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get time of ReviewStart (actual or estimated)
                            ?reviewStart a occp:ReviewStart .
                            { ?reviewStart occp:hasActualTime ?timeRS . }
                            UNION
                            { ?reviewStart occp:hasEstimatedTime ?timeRS . }
                            FILTER (?timeRA <= ?timeRS)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after ReviewStart { ?reviewStart } (time: { ?timeRS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ReviewRejectionShape a sh:NodeShape ;       # Instant Review Rejection (Phase B - Review)
                sh:targetClass occp:ReviewRejection ;
                # Ensure ReviewRejection occurs after ReviewStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewStart ?timeRR ?timeRS
                        WHERE {
                            # Get time of ReviewRejection (actual or estimated)
                            { $this occp:hasActualTime ?timeRR . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRR . }
                            # Get time of ReviewStart (actual or estimated)
                            ?reviewStart a occp:ReviewStart .
                            { ?reviewStart occp:hasActualTime ?timeRS . }
                            UNION
                            { ?reviewStart occp:hasEstimatedTime ?timeRS . }
                            FILTER (?timeRR <= ?timeRS)
                        }
                    """ ;
                    sh:message "ReviewRejection { $this } (time: { ?timeRR }) must occur after ReviewStart { ?reviewStart } (time: { ?timeRS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Instant (Review Rejection) ends current Cycle A (Planning/Review)
                sh:property [
                    sh:path occp:endsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewRejection' must end exactly one 'occp:CycleA_PlanningReview' via 'occp:endsCycle'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Instant (Review Rejection) starts a new Cycle A (Planning/Review)
                sh:property [
                    sh:path occp:startsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewRejection' must start exactly one new 'occp:CycleA_PlanningReview' via 'occp:startsCycle'."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE C INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseCInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseC_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseC_Construction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseC_Instant' must belong to exactly one 'occp:PhaseC_Construction' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE C - CONSTRUCTION

            osh:ConstructionStartShape a sh:NodeShape ;      # Instant Construction Start (Phase C - Construction)
                sh:targetClass occp:ConstructionStart ;
                # Instant (Construction Start) starts a new Phase C (Construction)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseC_Construction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ConstructionStart' must start exactly one 'occp:PhaseC_Construction' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionStart occurs before ConstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeCS ?timeCC
                        WHERE {
                            { $this occp:hasActualTime ?timeCS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCS . }
                            ?completion a occp:ConstructionCompletion .
                            { ?completion occp:hasActualTime ?timeCC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCC . }
                            FILTER (?timeCS >= ?timeCC)
                        }
                    """ ;
                    sh:message "ConstructionStart { $this } (time: { ?timeCS }) must occur before ConstructionCompletion { ?completion } (time: { ?timeCC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionStart occurs after Submission based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeCS ?timeSub
                        WHERE {
                            { $this occp:hasActualTime ?timeCS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCS . }
                            ?submission a occp:Submission .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeCS <= ?timeSub)
                        }
                    """ ;
                    sh:message "ConstructionStart { $this } (time: { ?timeCS }) must occur after Submission { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ConstructionCompletionShape a sh:NodeShape ; # Instant Construction Completion (Phase C - Construction)
                sh:targetClass occp:ConstructionCompletion ;
                # Ensure ConstructionCompletion occurs after ConstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeCC ?timeCS
                        WHERE {
                            { $this occp:hasActualTime ?timeCC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCC . }
                            ?start a occp:ConstructionStart .
                            { ?start occp:hasActualTime ?timeCS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeCS . }
                            FILTER (?timeCC <= ?timeCS)
                        }
                    """ ;
                    sh:message "ConstructionCompletion { $this } (time: { ?timeCC }) must occur after ConstructionStart { ?start } (time: { ?timeCS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionCompletion occurs before ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeCC ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeCC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCC . }
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeCC >= ?timeCA)
                        }
                    """ ;
                    sh:message "ConstructionCompletion { $this } (time: { ?timeCC }) must occur before ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionCompletion occurs before DefectElimStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectStart ?timeCC ?timeDES
                        WHERE {
                            { $this occp:hasActualTime ?timeCC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCC . }
                            ?defectStart a occp:DefectElimStart .
                            { ?defectStart occp:hasActualTime ?timeDES . }
                            UNION
                            { ?defectStart occp:hasEstimatedTime ?timeDES . }
                            FILTER (?timeCC >= ?timeDES)
                        }
                    """ ;
                    sh:message "ConstructionCompletion { $this } (time: { ?timeCC }) must occur before DefectElimStart { ?defectStart } (time: { ?timeDES })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DefectElimStartShape a sh:NodeShape ;        # Instant Defect Elimination Start (Phase C - Construction)
                sh:targetClass occp:DefectElimStart ;
                # Ensure DefectElimStart occurs after ConstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeDES ?timeCC
                        WHERE {
                            { $this occp:hasActualTime ?timeDES . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDES . }
                            ?completion a occp:ConstructionCompletion .
                            { ?completion occp:hasActualTime ?timeCC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCC . }
                            FILTER (?timeDES <= ?timeCC)
                        }
                    """ ;
                    sh:message "DefectElimStart { $this } (time: { ?timeDES }) must occur after ConstructionCompletion { ?completion } (time: { ?timeCC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DefectElimStart occurs before DefectElimCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectComp ?timeDES ?timeDEC
                        WHERE {
                            { $this occp:hasActualTime ?timeDES . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDES . }
                            ?defectComp a occp:DefectElimCompletion .
                            { ?defectComp occp:hasActualTime ?timeDEC . }
                            UNION
                            { ?defectComp occp:hasEstimatedTime ?timeDEC . }
                            FILTER (?timeDES >= ?timeDEC)
                        }
                    """ ;
                    sh:message "DefectElimStart { $this } (time: { ?timeDES }) must occur before DefectElimCompletion { ?defectComp } (time: { ?timeDEC })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DefectElimCompletionShape a sh:NodeShape ;   # Instant Defect Elimination Completion (Phase C - Construction)
                sh:targetClass occp:DefectElimCompletion ;
                # Ensure DefectElimCompletion occurs after DefectElimStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectStart ?timeDEC ?timeDES
                        WHERE {
                            { $this occp:hasActualTime ?timeDEC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDEC . }
                            ?defectStart a occp:DefectElimStart .
                            { ?defectStart occp:hasActualTime ?timeDES . }
                            UNION
                            { ?defectStart occp:hasEstimatedTime ?timeDES . }
                            FILTER (?timeDEC <= ?timeDES)
                        }
                    """ ;
                    sh:message "DefectElimCompletion { $this } (time: { ?timeDEC }) must occur after DefectElimStart { ?defectStart } (time: { ?timeDES })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DefectElimCompletion occurs before ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeDEC ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDEC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDEC . }
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDEC >= ?timeCA)
                        }
                    """ ;
                    sh:message "DefectElimCompletion { $this } (time: { ?timeDEC }) must occur before ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ConstructionAcceptanceShape a sh:NodeShape ; # Instant Construction Acceptance (Phase C - Construction)
                sh:targetClass occp:ConstructionAcceptance ;
                # Ensure ConstructionAcceptance occurs before UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeCA ?timeUS
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeCA >= ?timeUS)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) should occur before UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Warning
                ] ;
                # Ensure ConstructionAcceptance occurs before CompletionOfConstruction based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeCA ?timeCOC
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?completion a occp:CompletionOfConstruction .
                            { ?completion occp:hasActualTime ?timeCOC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCOC . }
                            FILTER (?timeCA >= ?timeCOC)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) must occur before CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionAcceptance occurs after ConstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeCA ?timeCC
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?completion a occp:ConstructionCompletion .
                            { ?completion occp:hasActualTime ?timeCC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCC . }
                            FILTER (?timeCA <= ?timeCC)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) must occur after ConstructionCompletion { ?completion } (time: { ?timeCC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionAcceptance occurs after DefectElimCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectComp ?timeCA ?timeDEC
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?defectComp a occp:DefectElimCompletion .
                            { ?defectComp occp:hasActualTime ?timeDEC . }
                            UNION
                            { ?defectComp occp:hasEstimatedTime ?timeDEC . }
                            FILTER (?timeCA <= ?timeDEC)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) must occur after DefectElimCompletion { ?defectComp } (time: { ?timeDEC })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE D INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseDInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseD_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseD_Instant' must belong to exactly one 'occp:PhaseD_Usage' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE D - USAGE
                
            osh:UsageStartShape a sh:NodeShape ;      # Instant Usage Start (Phase D - Usage)
                sh:targetClass occp:UsageStart ;
                # Instant (Usage Start) starts a new Phase D (Usage)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:UsageStart' must start exactly one 'occp:PhaseD_Usage' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constrAccept ?timeUS ?timeCA
                        WHERE {
                            # Get time of UsageStart (actual or estimated)
                            { $this occp:hasActualTime ?timeUS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUS . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constrAccept a occp:ConstructionAcceptance .
                            { ?constrAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constrAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeUS <= ?timeCA)
                        }
                    """ ;
                    sh:message "UsageStart { $this } (time: { ?timeUS }) must occur after ConstructionAcceptance { ?constrAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageStart occurs before UsageEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageEnd ?timeUS ?timeUE
                        WHERE {
                            # Get time of UsageStart (actual or estimated)
                            { $this occp:hasActualTime ?timeUS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUS . }
                            # Get time of UsageEnd (actual or estimated)
                            ?usageEnd a occp:UsageEnd .
                            { ?usageEnd occp:hasActualTime ?timeUE . }
                            UNION
                            { ?usageEnd occp:hasEstimatedTime ?timeUE . }
                            FILTER (?timeUS >= ?timeUE)
                        }
                    """ ;
                    sh:message "UsageStart { $this } (time: { ?timeUS }) must occur before UsageEnd { ?usageEnd } (time: { ?timeUE })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:UsageChangeShape a sh:NodeShape ;      # Instant Usage Change (Phase D - Usage)
                sh:targetClass occp:UsageChange ;
                # The current Usage Phase is ended with a Change of Usage
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:UsageChange' must end at least one 'occp:PhaseD_Usage' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # A new Usage Phase is started with a Change of Usage
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:UsageChange' must start at least one 'occp:PhaseD_Usage' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs after CompletionOfConstruction based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?compConstr ?timeUC ?timeCOC
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of CompletionOfConstruction (actual or estimated)
                            ?compConstr a occp:CompletionOfConstruction .
                            { ?compConstr occp:hasActualTime ?timeCOC . }
                            UNION
                            { ?compConstr occp:hasEstimatedTime ?timeCOC . }
                            FILTER (?timeUC <= ?timeCOC)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur after CompletionOfConstruction { ?compConstr } (time: { ?timeCOC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeUC ?timeUS
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeUC <= ?timeUS)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs before UsageEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageEnd ?timeUC ?timeUE
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of UsageEnd (actual or estimated)
                            ?usageEnd a occp:UsageEnd .
                            { ?usageEnd occp:hasActualTime ?timeUE . }
                            UNION
                            { ?usageEnd occp:hasEstimatedTime ?timeUE . }
                            FILTER (?timeUC >= ?timeUE)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur before UsageEnd { ?usageEnd } (time: { ?timeUE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeUC ?timeDS
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeUC >= ?timeDS)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:UsageEndShape a sh:NodeShape ;      # Instant Usage End (Phase D - Usage)
                sh:targetClass occp:UsageEnd ;
                # Instant (Usage End) ends a Usage Phase
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:UsageEnd' must end exactly one 'occp:PhaseD_Usage' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageEnd occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeUE ?timeUS
                        WHERE {
                            # Get time of UsageEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeUE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUE . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeUE <= ?timeUS)
                        }
                    """ ;
                    sh:message "UsageEnd { $this } (time: { ?timeUE }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageEnd occurs after UsageChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageChange ?timeUE ?timeUC
                        WHERE {
                            # Get time of UsageEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeUE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUE . }
                            # Get time of UsageChange (actual or estimated)
                            ?usageChange a occp:UsageChange .
                            { ?usageChange occp:hasActualTime ?timeUC . }
                            UNION
                            { ?usageChange occp:hasEstimatedTime ?timeUC . }
                            FILTER (?timeUE <= ?timeUC)
                        }
                    """ ;
                    sh:message "UsageEnd { $this } (time: { ?timeUE }) must occur after UsageChange { ?usageChange } (time: { ?timeUC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageEnd occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeUE ?timeDS
                        WHERE {
                            # Get time of UsageEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeUE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeUE >= ?timeDS)
                        }
                    """ ;
                    sh:message "UsageEnd { $this } (time: { ?timeUE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE E INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseEInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseE_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseE_Instant' must belong to exactly one 'occp:PhaseE_Warranty' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE E - WARRANTY
            osh:WarrantyStartShape a sh:NodeShape ;          # Instant Warranty Start (Phase E - Warranty)
                sh:targetClass occp:WarrantyStart ;
                # Instant (Warranty Start) starts a new Phase E (Warranty)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:WarrantyStart' must start exactly one 'occp:PhaseE_Warranty' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeWS ?timeCA
                        WHERE {
                            # Get time of WarrantyStart (actual or estimated)
                            { $this occp:hasActualTime ?timeWS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWS . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeWS <= ?timeCA)
                        }
                    """ ;
                    sh:message "WarrantyStart { $this } (time: { ?timeWS }) must occur after ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyStart occurs before WarrantyEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?end ?timeWS ?timeWE
                        WHERE {
                            # Get time of WarrantyStart (actual or estimated)
                            { $this occp:hasActualTime ?timeWS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWS . }
                            # Get time of WarrantyEnd (actual or estimated)
                            ?end a occp:WarrantyEnd .
                            { ?end occp:hasActualTime ?timeWE . }
                            UNION
                            { ?end occp:hasEstimatedTime ?timeWE . }
                            FILTER (?timeWS >= ?timeWE)
                        }
                    """ ;
                    sh:message "WarrantyStart { $this } (time: { ?timeWS }) must occur before WarrantyEnd { ?end } (time: { ?timeWE })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:WarrantyChangeShape a sh:NodeShape ;         # Instant Warranty Change (Phase E - Warranty)
                sh:targetClass occp:WarrantyChange ;
                # The current Warranty Phase is ended with a Change of Warranty
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:WarrantyChange' must end at least one 'occp:PhaseE_Warranty' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # A new Warranty Phase is started with a Change of Warranty
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:WarrantyChange' must start at least one 'occp:PhaseE_Warranty' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs after CompletionOfConstruction based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeWC ?timeCOC
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of CompletionOfConstruction (actual or estimated)
                            ?completion a occp:CompletionOfConstruction .
                            { ?completion occp:hasActualTime ?timeCOC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCOC . }
                            FILTER (?timeWC <= ?timeCOC)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs after WarrantyStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeWC ?timeWS
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of WarrantyStart (actual or estimated)
                            ?start a occp:WarrantyStart .
                            { ?start occp:hasActualTime ?timeWS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeWS . }
                            FILTER (?timeWC <= ?timeWS)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur after WarrantyStart { ?start } (time: { ?timeWS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs before WarrantyEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?end ?timeWC ?timeWE
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of WarrantyEnd (actual or estimated)
                            ?end a occp:WarrantyEnd .
                            { ?end occp:hasActualTime ?timeWE . }
                            UNION
                            { ?end occp:hasEstimatedTime ?timeWE . }
                            FILTER (?timeWC >= ?timeWE)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur before WarrantyEnd { ?end } (time: { ?timeWE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeWC ?timeDS
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeWC >= ?timeDS)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:WarrantyEndShape a sh:NodeShape ;            # Instant Warranty End (Phase E - Warranty)
                sh:targetClass occp:WarrantyEnd ;
                # The current Warranty Phase is ended with Warranty End
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:WarrantyEnd' must end exactly one 'occp:PhaseE_Warranty' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyEnd occurs after WarrantyStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeWE ?timeWS
                        WHERE {
                            # Get time of WarrantyEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of WarrantyStart (actual or estimated)
                            ?start a occp:WarrantyStart .
                            { ?start occp:hasActualTime ?timeWS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeWS . }
                            FILTER (?timeWE <= ?timeWS)
                        }
                    """ ;
                    sh:message "WarrantyEnd { $this } (time: { ?timeWE }) must occur after WarrantyStart { ?start } (time: { ?timeWS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyEnd occurs after WarrantyChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?change ?timeWE ?timeWC
                        WHERE {
                            # Get time of WarrantyEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of WarrantyChange (actual or estimated)
                            ?change a occp:WarrantyChange .
                            { ?change occp:hasActualTime ?timeWC . }
                            UNION
                            { ?change occp:hasEstimatedTime ?timeWC . }
                            FILTER (?timeWE <= ?timeWC)
                        }
                    """ ;
                    sh:message "WarrantyEnd { $this } (time: { ?timeWE }) must occur after WarrantyChange { ?change } (time: { ?timeWC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyEnd occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeWE ?timeDS
                        WHERE {
                            # Get time of WarrantyEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeWE >= ?timeDS)
                        }
                    """ ;
                    sh:message "WarrantyEnd { $this } (time: { ?timeWE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE F INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseFInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseF_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseF_Instant' must belong to exactly one 'occp:PhaseF_DesignLife' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE F - DESIGN LIFE
            osh:DesignLifeStartShape a sh:NodeShape ;        # Instant Design Life Start (Phase F - Design Life)
                sh:targetClass occp:DesignLifeStart ;
                # Instant (Design Life Start) starts a new Phase F (Design Life)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DesignLifeStart' must start exactly one 'occp:PhaseF_DesignLife' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeDLS ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDLS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLS . }
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDLS <= ?timeCA)
                        }
                    """ ;
                    sh:message "DesignLifeStart { $this } (time: { ?timeDLS }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeStart occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconstStart ?timeDLS ?timeDS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLS . }
                            ?deconstStart a occp:DeconstructionStart .
                            { ?deconstStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconstStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDLS >= ?timeDS)
                        }
                    """ ;
                    sh:message "DesignLifeStart { $this } (time: { ?timeDLS }) must occur before DeconstructionStart { ?deconstStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeStart occurs before DesignLifeEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designEnd ?timeDLS ?timeDLE
                        WHERE {
                            { $this occp:hasActualTime ?timeDLS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLS . }
                            ?designEnd a occp:DesignLifeEnd .
                            { ?designEnd occp:hasActualTime ?timeDLE . }
                            UNION
                            { ?designEnd occp:hasEstimatedTime ?timeDLE . }
                            FILTER (?timeDLS >= ?timeDLE)
                        }
                    """ ;
                    sh:message "DesignLifeStart { $this } (time: { ?timeDLS }) must occur before DesignLifeEnd { ?designEnd } (time: { ?timeDLE })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DesignLifeChangeShape a sh:NodeShape ;       # Instant Design Life Change (Phase F - Design Life)
                sh:targetClass occp:DesignLifeChange ;
                # The current Design Life Phase is ended with a Change of Design Life
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:DesignLifeChange' must end at least one 'occp:PhaseF_DesignLife' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # A new Design Life Phase is started with a Change of Design Life
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:DesignLifeChange' must start at least one 'occp:PhaseF_DesignLife' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeDLC ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDLC <= ?timeCA)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs after DesignLifeStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designStart ?timeDLC ?timeDLS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?designStart a occp:DesignLifeStart .
                            { ?designStart occp:hasActualTime ?timeDLS . }
                            UNION
                            { ?designStart occp:hasEstimatedTime ?timeDLS . }
                            FILTER (?timeDLC <= ?timeDLS)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur after DesignLifeStart { ?designStart } (time: { ?timeDLS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs before DesignLifeEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designEnd ?timeDLC ?timeDLE
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?designEnd a occp:DesignLifeEnd .
                            { ?designEnd occp:hasActualTime ?timeDLE . }
                            UNION
                            { ?designEnd occp:hasEstimatedTime ?timeDLE . }
                            FILTER (?timeDLC >= ?timeDLE)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur before DesignLifeEnd { ?designEnd } (time: { ?timeDLE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconstStart ?timeDLC ?timeDS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?deconstStart a occp:DeconstructionStart .
                            { ?deconstStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconstStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDLC >= ?timeDS)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur before DeconstructionStart { ?deconstStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DesignLifeEndShape a sh:NodeShape ;          # Instant Design Life End (Phase F - Design Life)
                sh:targetClass occp:DesignLifeEnd ;
                # The current Design Life Phase is ended with Design Life End
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DesignLifeEnd' must end exactly one 'occp:PhaseF_DesignLife' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs after DesignLifeStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designStart ?timeDLE ?timeDLS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?designStart a occp:DesignLifeStart .
                            { ?designStart occp:hasActualTime ?timeDLS . }
                            UNION
                            { ?designStart occp:hasEstimatedTime ?timeDLS . }
                            FILTER (?timeDLE <= ?timeDLS)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur after DesignLifeStart { ?designStart } (time: { ?timeDLS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs after DesignLifeChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designChange ?timeDLE ?timeDLC
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?designChange a occp:DesignLifeChange .
                            { ?designChange occp:hasActualTime ?timeDLC . }
                            UNION
                            { ?designChange occp:hasEstimatedTime ?timeDLC . }
                            FILTER (?timeDLE <= ?timeDLC)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur after DesignLifeChange { ?designChange } (time: { ?timeDLC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeDLE ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDLE <= ?timeCA)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconstStart ?timeDLE ?timeDS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?deconstStart a occp:DeconstructionStart .
                            { ?deconstStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconstStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDLE >= ?timeDS)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur before DeconstructionStart { ?deconstStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

        
    ### PHASE G INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseGInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseG_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseG_Inspection ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseG_Instant' must belong to exactly one 'occp:PhaseG_Inspection' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE G - INSPECTION
            osh:InspectionExecutionShape a sh:NodeShape ;    # Instant Inspection Execution (Phase G - Inspection)
                sh:targetClass occp:InspectionExecution ;
                # Ensure InspectionExecution occurs after ConstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constStart ?timeIE ?timeCS
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of ConstructionStart (actual or estimated)
                            ?constStart a occp:ConstructionStart .
                            { ?constStart occp:hasActualTime ?timeCS . }
                            UNION
                            { ?constStart occp:hasEstimatedTime ?timeCS . }
                            FILTER (?timeIE <= ?timeCS)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur after ConstructionStart { ?constStart } (time: { ?timeCS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure InspectionExecution occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeIE ?timeUS
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeIE <= ?timeUS)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure InspectionExecution occurs after UsageChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageChange ?timeIE ?timeUC
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of UsageChange (actual or estimated)
                            ?usageChange a occp:UsageChange .
                            { ?usageChange occp:hasActualTime ?timeUC . }
                            UNION
                            { ?usageChange occp:hasEstimatedTime ?timeUC . }
                            FILTER (?timeIE <= ?timeUC)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur after UsageChange { ?usageChange } (time: { ?timeUC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure InspectionExecution occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeIE ?timeDS
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeIE >= ?timeDS)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:IrregularInspectionShape a sh:NodeShape ;    # Instant Irregular Inspection (Phase G - Inspection)
                sh:targetClass occp:IrregularInspection ;
                # Ensure IrregularInspection occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeII ?timeUS
                        WHERE {
                            # Get time of IrregularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeII . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeII . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeII <= ?timeUS)
                        }
                    """ ;
                    sh:message "IrregularInspection { $this } (time: { ?timeII }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure IrregularInspection occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeII ?timeDS
                        WHERE {
                            # Get time of IrregularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeII . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeII . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeII >= ?timeDS)
                        }
                    """ ;
                    sh:message "IrregularInspection { $this } (time: { ?timeII }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:NextRegularInspectionShape a sh:NodeShape ;  # Instant Next Regular Inspection (Phase G - Inspection)
                sh:targetClass occp:NextRegularInspection ;
                # Ensure NextRegularInspection occurs after InspectionExecution based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?inspExec ?timeNRI ?timeIE
                        WHERE {
                            # Get time of NextRegularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeNRI . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeNRI . }
                            # Get time of InspectionExecution (actual or estimated)
                            ?inspExec a occp:InspectionExecution .
                            { ?inspExec occp:hasActualTime ?timeIE . }
                            UNION
                            { ?inspExec occp:hasEstimatedTime ?timeIE . }
                            FILTER (?timeNRI <= ?timeIE)
                        }
                    """ ;
                    sh:message "NextRegularInspection { $this } (time: { ?timeNRI }) must occur after InspectionExecution { ?inspExec } (time: { ?timeIE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure NextRegularInspection occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeNRI ?timeUS
                        WHERE {
                            # Get time of NextRegularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeNRI . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeNRI . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeNRI <= ?timeUS)
                        }
                    """ ;
                    sh:message "NextRegularInspection { $this } (time: { ?timeNRI }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure NextRegularInspection occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeNRI ?timeDS
                        WHERE {
                            # Get time of NextRegularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeNRI . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeNRI . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeNRI >= ?timeDS)
                        }
                    """ ;
                    sh:message "NextRegularInspection { $this } (time: { ?timeNRI }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE H INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseHInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseH_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseH_SpecialEvents ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseH_Instant' must belong to exactly one 'occp:PhaseH_SpecialEvents' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE H - SPECIAL EVENTS
            osh:GeologicalEventShape a sh:NodeShape ;        # Instant Geological Event (Phase H - Special Events)
                sh:targetClass occp:GeologicalEvent ;
                # Ensure GeologicalEvent occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeGE ?timeCA
                        WHERE {
                            # Get time of GeologicalEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeGE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeGE . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeGE <= ?timeCA)
                        }
                    """ ;
                    sh:message "GeologicalEvent { $this } (time: { ?timeGE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure GeologicalEvent occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeGE ?timeDS
                        WHERE {
                            # Get time of GeologicalEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeGE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeGE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeGE >= ?timeDS)
                        }
                    """ ;
                    sh:message "GeologicalEvent { $this } (time: { ?timeGE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:LoadEventShape a sh:NodeShape ;              # Instant Load Event (Phase H - Special Events)
                sh:targetClass occp:LoadEvent ;
                # Ensure LoadEvent occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeLE ?timeCA
                        WHERE {
                            # Get time of LoadEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeLE . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeLE <= ?timeCA)
                        }
                    """ ;
                    sh:message "LoadEvent { $this } (time: { ?timeLE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure LoadEvent occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeLE ?timeDS
                        WHERE {
                            # Get time of LoadEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeLE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeLE >= ?timeDS)
                        }
                    """ ;
                    sh:message "LoadEvent { $this } (time: { ?timeLE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:WeatherEventShape a sh:NodeShape ;           # Instant Weather Event (Phase H - Special Events)
                sh:targetClass occp:WeatherEvent ;
                # Ensure WeatherEvent occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeWE ?timeCA
                        WHERE {
                            # Get time of WeatherEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeWE <= ?timeCA)
                        }
                    """ ;
                    sh:message "WeatherEvent { $this } (time: { ?timeWE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WeatherEvent occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeWE ?timeDS
                        WHERE {
                            # Get time of WeatherEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeWE >= ?timeDS)
                        }
                    """ ;
                    sh:message "WeatherEvent { $this } (time: { ?timeWE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE K INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseKInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseK_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseK_Damage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseK_Instant' must belong to exactly one 'occp:PhaseK_Damage' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE K - DAMAGE
            osh:DamageDetectionShape a sh:NodeShape ;        # Instant Damage Detection (Phase K - Damage)
                sh:targetClass occp:DamageDetection ;
                # Instant (Damage Detection) starts a new Phase K (Damage)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseK_Damage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DamageDetection' must start exactly one 'occp:PhaseK_Damage' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageDetection occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?conAccept ?timeDD ?timeCA
                        WHERE {
                            # Get time of DamageDetection (actual or estimated)
                            { $this occp:hasActualTime ?timeDD . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDD . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?conAccept a occp:ConstructionAcceptance .
                            { ?conAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?conAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDD <= ?timeCA)
                        }
                    """ ;
                    sh:message "DamageDetection { $this } (time: { ?timeDD }) must occur after ConstructionAcceptance { ?conAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageDetection occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeDD ?timeDS
                        WHERE {
                            # Get time of DamageDetection (actual or estimated)
                            { $this occp:hasActualTime ?timeDD . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDD . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDD >= ?timeDS)
                        }
                    """ ;
                    sh:message "DamageDetection { $this } (time: { ?timeDD }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DamageObservationShape a sh:NodeShape ;      # Instant Damage Observation (Phase K - Damage)
                sh:targetClass occp:DamageObservation ;
                # Ensure DamageObservation occurs after DamageDetection based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?damageDetect ?timeDO ?timeDD
                        WHERE {
                            # Get time of DamageObservation (actual or estimated)
                            { $this occp:hasActualTime ?timeDO . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDO . }
                            # Get time of DamageDetection (actual or estimated)
                            ?damageDetect a occp:DamageDetection .
                            { ?damageDetect occp:hasActualTime ?timeDD . }
                            UNION
                            { ?damageDetect occp:hasEstimatedTime ?timeDD . }
                            FILTER (?timeDO <= ?timeDD)
                        }
                    """ ;
                    sh:message "DamageObservation { $this } (time: { ?timeDO }) must occur after DamageDetection { ?damageDetect } (time: { ?timeDD })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageObservation occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeDO ?timeDS
                        WHERE {
                            # Get time of DamageObservation (actual or estimated)
                            { $this occp:hasActualTime ?timeDO . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDO . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDO >= ?timeDS)
                        }
                    """ ;
                    sh:message "DamageObservation { $this } (time: { ?timeDO }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DamageRepairShape a sh:NodeShape ;           # Instant Damage Repair (Phase K - Damage)
                sh:targetClass occp:DamageRepair ;
                # Ensure DamageRepair occurs after DamageDetection based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?damageDetect ?timeDR ?timeDD
                        WHERE {
                            # Get time of DamageRepair (actual or estimated)
                            { $this occp:hasActualTime ?timeDR . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDR . }
                            # Get time of DamageDetection (actual or estimated)
                            ?damageDetect a occp:DamageDetection .
                            { ?damageDetect occp:hasActualTime ?timeDD . }
                            UNION
                            { ?damageDetect occp:hasEstimatedTime ?timeDD . }
                            FILTER (?timeDR <= ?timeDD)
                        }
                    """ ;
                    sh:message "DamageRepair { $this } (time: { ?timeDR }) must occur after DamageDetection { ?damageDetect } (time: { ?timeDD })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageRepair occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeDR ?timeDS
                        WHERE {
                            # Get time of DamageRepair (actual or estimated)
                            { $this occp:hasActualTime ?timeDR . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDR . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDR >= ?timeDS)
                        }
                    """ ;
                    sh:message "DamageRepair { $this } (time: { ?timeDR }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE L INSTANTS
        # PHASE ASSIGNMENT
        osh:NewComponentShape a sh:NodeShape ;           # Instant New Component (Phase L - Repair)
            sh:targetClass occp:NewComponent ;
            # Ensure NewComponent occurs after ConstructionCompletion based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?constComp ?timeNC ?timeCC
                    WHERE {
                        # Get time of NewComponent (actual or estimated)
                        { $this occp:hasActualTime ?timeNC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeNC . }
                        # Get time of ConstructionCompletion (actual or estimated)
                        ?constComp a occp:ConstructionCompletion .
                        { ?constComp occp:hasActualTime ?timeCC . }
                        UNION
                        { ?constComp occp:hasEstimatedTime ?timeCC . }
                        FILTER (?timeNC <= ?timeCC)
                    }
                """ ;
                sh:message "NewComponent { $this } (time: { ?timeNC }) must occur after ConstructionCompletion { ?constComp } (time: { ?timeCC })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure NewComponent occurs before DeconstructionStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?deconStart ?timeNC ?timeDS
                    WHERE {
                        # Get time of NewComponent (actual or estimated)
                        { $this occp:hasActualTime ?timeNC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeNC . }
                        # Get time of DeconstructionStart (actual or estimated)
                        ?deconStart a occp:DeconstructionStart .
                        { ?deconStart occp:hasActualTime ?timeDS . }
                        UNION
                        { ?deconStart occp:hasEstimatedTime ?timeDS . }
                        FILTER (?timeNC >= ?timeDS)
                    }
                """ ;
                sh:message "NewComponent { $this } (time: { ?timeNC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                sh:severity sh:Violation
            ] .

        osh:RepairStartShape a sh:NodeShape ;            # Instant Repair Start (Phase L - Repair)
            sh:targetClass occp:RepairStart ;
            # Instant (Repair Start) starts a new Phase L (Repair)
            sh:property [
                sh:path occp:startsPhase ;
                sh:class occp:PhaseL_Repair ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:RepairStart' must start exactly one 'occp:PhaseL_Repair' via 'occp:startsPhase'."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairStart occurs after DamageDetection based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?damageDet ?timeRS ?timeDD
                    WHERE {
                        # Get time of RepairStart (actual or estimated)
                        { $this occp:hasActualTime ?timeRS . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRS . }
                        # Get time of DamageDetection (actual or estimated)
                        ?damageDet a occp:DamageDetection .
                        { ?damageDet occp:hasActualTime ?timeDD . }
                        UNION
                        { ?damageDet occp:hasEstimatedTime ?timeDD . }
                        FILTER (?timeRS <= ?timeDD)
                    }
                """ ;
                sh:message "RepairStart { $this } (time: { ?timeRS }) must occur after DamageDetection { ?damageDet } (time: { ?timeDD })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairStart occurs before RepairCompletion based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?repairComp ?timeRS ?timeRC
                    WHERE {
                        # Get time of RepairStart (actual or estimated)
                        { $this occp:hasActualTime ?timeRS . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRS . }
                        # Get time of RepairCompletion (actual or estimated)
                        ?repairComp a occp:RepairCompletion .
                        { ?repairComp occp:hasActualTime ?timeRC . }
                        UNION
                        { ?repairComp occp:hasEstimatedTime ?timeRC . }
                        FILTER (?timeRS >= ?timeRC)
                    }
                """ ;
                sh:message "RepairStart { $this } (time: { ?timeRS }) must occur before RepairCompletion { ?repairComp } (time: { ?timeRC })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairStart occurs before DeconstructionStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?deconStart ?timeRS ?timeDS
                    WHERE {
                        # Get time of RepairStart (actual or estimated)
                        { $this occp:hasActualTime ?timeRS . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRS . }
                        # Get time of DeconstructionStart (actual or estimated)
                        ?deconStart a occp:DeconstructionStart .
                        { ?deconStart occp:hasActualTime ?timeDS . }
                        UNION
                        { ?deconStart occp:hasEstimatedTime ?timeDS . }
                        FILTER (?timeRS >= ?timeDS)
                    }
                """ ;
                sh:message "RepairStart { $this } (time: { ?timeRS }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                sh:severity sh:Violation
            ] .

        osh:RepairCompletionShape a sh:NodeShape ;       # Instant Repair Completion (Phase L - Repair)
            sh:targetClass occp:RepairCompletion ;
            # Instant (Repair Completion) ends a Phase L (Repair)
            sh:property [
                sh:path occp:endsPhase ;
                sh:class occp:PhaseL_Repair ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:RepairCompletion' must end exactly one 'occp:PhaseL_Repair' via 'occp:endsPhase'."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairCompletion occurs after RepairStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?repairStart ?timeRC ?timeRS
                    WHERE {
                        # Get time of RepairCompletion (actual or estimated)
                        { $this occp:hasActualTime ?timeRC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRC . }
                        # Get time of RepairStart (actual or estimated)
                        ?repairStart a occp:RepairStart .
                        { ?repairStart occp:hasActualTime ?timeRS . }
                        UNION
                        { ?repairStart occp:hasEstimatedTime ?timeRS . }
                        FILTER (?timeRC <= ?timeRS)
                    }
                """ ;
                sh:message "RepairCompletion { $this } (time: { ?timeRC }) must occur after RepairStart { ?repairStart } (time: { ?timeRS })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairCompletion occurs before DeconstructionStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?deconStart ?timeRC ?timeDS
                    WHERE {
                        # Get time of RepairCompletion (actual or estimated)
                        { $this occp:hasActualTime ?timeRC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRC . }
                        # Get time of DeconstructionStart (actual or estimated)
                        ?deconStart a occp:DeconstructionStart .
                        { ?deconStart occp:hasActualTime ?timeDS . }
                        UNION
                        { ?deconStart occp:hasEstimatedTime ?timeDS . }
                        FILTER (?timeRC >= ?timeDS)
                    }
                """ ;
                sh:message "RepairCompletion { $this } (time: { ?timeRC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                sh:severity sh:Violation
            ] .


    ### PHASE M INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseMInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseM_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseM_Deconstruction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseM_Instant' must belong to exactly one 'occp:PhaseM_Deconstruction' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE M - DECONSTRUCTION
            osh:DeconstructionStartShape a sh:NodeShape ;    # Instant Deconstruction Start (Phase M - Deconstruction)
                sh:targetClass occp:DeconstructionStart ;
                # Instant (Deconstruction Start) starts a new Phase M (Deconstruction)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseM_Deconstruction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DeconstructionStart' must start exactly one 'occp:PhaseM_Deconstruction' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DeconstructionStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeDS ?timeCA
                        WHERE {
                            # Get time of DeconstructionStart (actual or estimated)
                            { $this occp:hasActualTime ?timeDS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDS . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDS <= ?timeCA)
                        }
                    """ ;
                    sh:message "DeconstructionStart { $this } (time: { ?timeDS }) must occur after ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DeconstructionStart occurs before DeconstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeDS ?timeDC
                        WHERE {
                            # Get time of DeconstructionStart (actual or estimated)
                            { $this occp:hasActualTime ?timeDS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDS . }
                            # Get time of DeconstructionCompletion (actual or estimated)
                            ?completion a occp:DeconstructionCompletion .
                            { ?completion occp:hasActualTime ?timeDC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeDC . }
                            FILTER (?timeDS >= ?timeDC)
                        }
                    """ ;
                    sh:message "DeconstructionStart { $this } (time: { ?timeDS }) must occur before DeconstructionCompletion { ?completion } (time: { ?timeDC })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DeconstructionCompletionShape a sh:NodeShape ;   # Instant Deconstruction Completion (Phase M - Deconstruction)
                sh:targetClass occp:DeconstructionCompletion ;
                # Instant (Deconstruction Completion) ends a Phase M (Deconstruction)
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseM_Deconstruction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DeconstructionCompletion' must end exactly one 'occp:PhaseM_Deconstruction' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DeconstructionCompletion occurs after DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeDC ?timeDS
                        WHERE {
                            # Get time of DeconstructionCompletion (actual or estimated)
                            { $this occp:hasActualTime ?timeDC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDC . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?start a occp:DeconstructionStart .
                            { ?start occp:hasActualTime ?timeDS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDC <= ?timeDS)
                        }
                    """ ;
                    sh:message "DeconstructionCompletion { $this } (time: { ?timeDC }) must occur after DeconstructionStart { ?start } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation ] .



#################################################################
#    ADDITIONAL SPARQL Queries
#################################################################

### GENERIC TIME QUERIES

    ### occp:before
    osh:BeforeTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?latestEndTime ?earliestStartTime WHERE {
                    $this occp:before ?other .
                    {
                        SELECT $this (MAX(?endTime) AS ?latestEndTime)
                        WHERE {
                            $this time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MIN(?startTime) AS ?earliestStartTime)
                        WHERE {
                            ?other time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?latestEndTime >= ?earliestStartTime)
                }
            """ ;
            sh:message "The latest end of { $this } (time: { ?latestEndTime }) must be before the earliest beginning of { ?other } (time: { ?earliestStartTime }) via 'occp:before'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:after
    osh:AfterTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?earliestStartTime ?latestEndTime WHERE {
                    $this occp:after ?other .
                    {
                        SELECT $this (MIN(?startTime) AS ?earliestStartTime)
                        WHERE {
                            $this time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MAX(?endTime) AS ?latestEndTime)
                        WHERE {
                            ?other time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?earliestStartTime <= ?latestEndTime)
                }
            """ ;
            sh:message "The earliest beginning of { $this } (time: { ?earliestStartTime }) must be after the latest end of { ?other } (time: { ?latestEndTime }) via 'occp:after'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:beginsBefore
    osh:BeginsBeforeTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?latestStartTime ?earliestStartTime WHERE {
                    $this occp:beginsBefore ?other .
                    {
                        SELECT $this (MAX(?startTime) AS ?latestStartTime)
                        WHERE {
                            $this time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MIN(?startTime) AS ?earliestStartTime)
                        WHERE {
                            ?other time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?latestStartTime >= ?earliestStartTime)
                }
            """ ;
            sh:message "The latest beginning of { $this } (time: { ?latestStartTime }) must be before the earliest beginning of { ?other } (time: { ?earliestStartTime }) via 'occp:beginsBefore'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:endsBefore
    osh:EndsBeforeTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?latestEndTime ?earliestEndTime WHERE {
                    $this occp:endsBefore ?other .
                    {
                        SELECT $this (MAX(?endTime) AS ?latestEndTime)
                        WHERE {
                            $this time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MIN(?endTime) AS ?earliestEndTime)
                        WHERE {
                            ?other time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?latestEndTime >= ?earliestEndTime)
                }
            """ ;
            sh:message "The latest end of { $this } (time: { ?latestEndTime }) must be before the earliest end of { ?other } (time: { ?earliestEndTime }) via 'occp:endsBefore'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:endsAfter
    osh:EndsAfterTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?earliestEndTime ?latestEndTime WHERE {
                    $this occp:endsAfter ?other .
                    {
                        SELECT $this (MIN(?endTime) AS ?earliestEndTime)
                        WHERE {
                            $this time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MAX(?endTime) AS ?latestEndTime)
                        WHERE {
                            ?other time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?earliestEndTime <= ?latestEndTime)
                }
            """ ;
            sh:message "The earliest end of { $this } (time: { ?earliestEndTime }) must be after the latest end of { ?other } (time: { ?latestEndTime }) via 'occp:endsAfter'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:beginsWith
    osh:BeginsWithTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?startTimeThis ?startTimeOther WHERE {
                    $this occp:beginsWith ?other .
                    {
                        SELECT $this (MIN(?startTime) AS ?startTimeThis)
                        WHERE {
                            $this time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MIN(?startTime) AS ?startTimeOther)
                        WHERE {
                            ?other time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?startTimeThis != ?startTimeOther)
                }
            """ ;
            sh:message "The earliest beginning of { $this } (time: { ?startTimeThis }) must equal the earliest beginning of { ?other } (time: { ?startTimeOther }) via 'occp:beginsWith'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:endsWith
    osh:EndsWithTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?endTimeThis ?endTimeOther WHERE {
                    $this occp:endsWith ?other .
                    {
                        SELECT $this (MAX(?endTime) AS ?endTimeThis)
                        WHERE {
                            $this time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MAX(?endTime) AS ?endTimeOther)
                        WHERE {
                            ?other time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?endTimeThis != ?endTimeOther)
                }
            """ ;
            sh:message "The latest end of { $this } (time: { ?endTimeThis }) must equal the latest end of { ?other } (time: { ?endTimeOther }) via 'occp:endsWith'."@en ;
            sh:severity sh:Violation
        ] .